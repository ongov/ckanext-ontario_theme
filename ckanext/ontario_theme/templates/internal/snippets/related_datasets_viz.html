{# JavaScript Function to display observable svg
    Modify function to take package id #}
{% set data = h.ontario_theme_hackathon_json() %}
{% block javascript %}
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script type="module">
        const networkOrdersChart = (data) => {
            const container = document.getElementById('svg-container');
            // Specify the dimensions of the chart.
            const width = 428;
            const height = 280;

            // CSS
            const css = {
                "fill": {"centreNode": "#FDDA0D", "order0": "#add8e6", "order1": "grey"},
                "stroke": {"node": "#969696",
                        "link": "#999"
                        },
                "strokeWidth": {"node": 0.9, "link": 2},
                "strokeOpacity": {"link": 0.6}
            };

            // Specify the color scale.
            const color = d3.scaleOrdinal(d3.schemeCategory10);
            const colorLinks = d3.scaleOrdinal(d3.schemeGreys[8]);

            // The force simulation mutates links and nodes, so create a copy
            // so that re-evaluating this cell produces the same result.
            const links = data.links.map(d => ({...d}));
            const nodes = data.nodes.map(d => ({...d}));

            const isWeighted = Object.keys(nodes[0]).indexOf('value') < 0 ? false : true

            // Create a simulation with several forces.
            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).strength(1.9))
                .force("charge", d3.forceManyBody())
                .force("x", d3.forceX())
                .force("y", d3.forceY());

            // Create the SVG container.
            const svg = d3.create("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [-width / 3, -height / 3.5, width/2, height/2])
                .attr("style", "max-width: 150%; height: auto;");

            // Add a line for each link, and a circle for each node.
            const link = svg.append("g")
                .attr("stroke", css.stroke.link)
                .attr("stroke-opacity", css.strokeOpacity.link)
                .selectAll("line")
                .data(links)
                .join("line")
                .attr("stroke-width", d => {
                let thisWidth = isWeighted ? Math.sqrt(d.value) : css.strokeWidth.link;
                return thisWidth;
                })
                .attr("stroke", d => d.value );

                const node = svg.append("g")
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 1.5)
                    .selectAll("circle")
                    .data(nodes)
                    .join("circle")
                    .attr("r", d => {
                    let isCentre = d.centre ? true: false;
                    let circleVal = isWeighted ? 2 * Math.sqrt(d.value) : 5;
                    return isCentre ? 12 : circleVal;
                    })
                    .attr("stroke", d => {
                    return css.stroke.node;
                    })
                    .attr("stroke-width", css.strokeWidth.node)
                    .attr("fill", d => {
                    let isCentre = d.centre ? true: false;
                    let thisFill;
                    if (isCentre) {
                        thisFill = css.fill.centreNode;
                    } else {
                        if (isWeighted) {
                        //TODO divide by max value
                        thisFill = d.order === 0 ? d3.interpolateBlues(d.value/10) : d3.interpolateGreys(d.value/10);
                        } else {
                        thisFill = d.order === 0 ? css.fill.order0 : css.fill.order1;
                        }
                    }
                    return thisFill;
                    }); 

            node.append("title")
                .text(d => d.title);

            // ************************************************
            // MOUSE ACTIONS
            // ************************************************
            node.on("click", (event, d) => {    
                window.open(
                `https://data.ontario.ca/dataset/${d.name}`,
                "_blank"
                );                    
            });

            // Add a drag behavior.
            node.call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));
            
            // Set the position attributes of links and nodes each time the simulation ticks.
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
            });

            // Reheat the simulation when drag starts, and fix the subject position.
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            // Update the subject (dragged node) position during drag.
            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            // Restore the target alpha so the simulation cools after dragging ends.
            // Unfix the subject position now that it's no longer being dragged.
            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }

            // When this cell is re-run, stop the previous simulation. (This doesn't
            // really matter since the target alpha is zero and the simulation will
            // stop naturally, but it's a good practice.)
            // invalidation.then(() => simulation.stop());

            container.append(svg.node());
        }
        networkOrdersChart({{ data|tojson }})
    </script>
{% endblock javascript %}
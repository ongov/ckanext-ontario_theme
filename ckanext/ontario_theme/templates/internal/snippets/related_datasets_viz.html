{# JavaScript Function to display observable svg
    Modify function to take package id #}
{% set data = h.ontario_theme_hackathon_json() %}
{% block javascript %}
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script type="module">
        const networkOrdersChart = (data) => {
            const container = document.getElementById('svg-container');
            // Specify the dimensions of the chart.
            const width = 428;
            const height = 280;

            // Specify the color scale.
            const color = d3.scaleOrdinal(d3.schemeCategory10);
            const colorLinks = d3.scaleOrdinal(d3.schemeGreys[8]);

            // The force simulation mutates links and nodes, so create a copy
            // so that re-evaluating this cell produces the same result.
            const links = data.links.map(d => ({...d}));
            const nodes = data.nodes.map(d => ({...d}));

            const isWeighted = Object.keys(nodes[0]).indexOf('value') < 0 ? false : true

            // Create a simulation with several forces.
            const simulation = d3.forceSimulation(nodes)
                //.force("link", d3.forceLink(links).id(d => d.id))
                //.force("link", d3.forceLink(links).id(d => d.id).distance(0).strength(1))
                .force("link", d3.forceLink(links).id(d => d.id).strength(1.9))
                //.force("charge", d3.forceManyBody().strength(-50))
                .force("charge", d3.forceManyBody())
                .force("x", d3.forceX())
                .force("y", d3.forceY());

            // Create the SVG container.
            const svg = d3.create("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [-width / 3, -height / 3.5, width/2, height/2])
                .attr("style", "max-width: 150%; height: auto;");

            // Add a line for each link, and a circle for each node.
            const link = svg.append("g")
                .attr("stroke", "#999")
                .attr("stroke-opacity", 0.6)
                .selectAll("line")
                .data(links)
                .join("line")
                .attr("stroke-width", d => {
                let thisWidth = isWeighted ? Math.sqrt(d.value) : 2;
                return thisWidth;
                })
                .attr("stroke", d => d.value )
            ;

            const node = svg.append("g")
                .attr("stroke", "#fff")
                .attr("stroke-width", 1.5)
                .selectAll("circle")
                .data(nodes)
                .join("circle")
                .attr("r", d => {
                let circleVal = isWeighted ? 2 * Math.sqrt(d.value) : 5;
                return d.id === "THIS_PACKAGE" ? 12 : circleVal;
                })
                .attr("stroke", d => {
                return d.order === 0 ? "#336699" : "none";
                })
                .attr("stroke-width", 0.9)
                .attr("fill", d => {
                console.log('node: ', d)
                let thisFill;
                if (isWeighted) {
                    //TODO divide by max value
                    thisFill = d.order === 0 ? d3.interpolateBlues(d.value/10) : d3.interpolateGreys(d.value/10);
                } else {
                    thisFill = d.order === 0 ? "#add8e6" : "grey";
                }
                // return color(d.group)
                return thisFill;
                })
                // .attr("opacity", d => {
                //   return d.order === 0 ? 1 : 0.5;
                // })  
                ; 

            node.append("title")
                .text(d => d.id);

            // Add a drag behavior.
            node.call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));
            
            // Set the position attributes of links and nodes each time the simulation ticks.
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
            });

            // Reheat the simulation when drag starts, and fix the subject position.
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            // Update the subject (dragged node) position during drag.
            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            // Restore the target alpha so the simulation cools after dragging ends.
            // Unfix the subject position now that it's no longer being dragged.
            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }

            // When this cell is re-run, stop the previous simulation. (This doesn't
            // really matter since the target alpha is zero and the simulation will
            // stop naturally, but it's a good practice.)
            // invalidation.then(() => simulation.stop());

            container.append(svg.node());
        }
        networkOrdersChart({{ data|tojson }})
    </script>
{% endblock javascript %}